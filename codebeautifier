#!/usr/bin/env python

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
from abc import abstractmethod


def searchProgram(match):
    regex = re.compile(match)
    paths = os.getenv("PATH").split(":")
    candidates = []
    visited = {}

    # For all directories in $PATH
    for p in paths:
        if os.path.isdir(p):
            # For all files in a subdirectory
            for f in os.listdir(p):
                absfile = os.path.join(p, f)
                # Directory was not visited before
                if not absfile in visited:
                    # File in directory is an executable file
                    if os.path.isfile(absfile) and os.access(absfile, os.X_OK):
                        # It fulfills the regex
                        if regex.match(f) != None:
                            candidates.append(absfile)
                    # Mark the directory to visit it only once
                    visited[absfile] = True

    return candidates


class PathProcessor(object):
    def processPath(self, path, exceptions):
        if os.path.isdir(path):
            self.processDir(os.path.abspath(path), exceptions)
        else:
            self.processFile(os.path.abspath(path), exceptions)

    def processDir(self, path, exceptions):
        shallBeAvoided = False
        if exceptions != None:
            for e in exceptions:
                shallBeAvoided = shallBeAvoided or (re.match(e, path) != None)
        if not shallBeAvoided:
            if os.path.isdir(path):
                lst = os.listdir(path)
                for p in lst:
                    folder = os.path.join(path, p)
                    if os.path.isdir(folder):
                        self.processDir(folder, exceptions)
                    else:
                        self.processFile(folder, exceptions)
            else:
                raise RuntimeError("'{0}' is not a directory".format(p))

    @abstractmethod
    def processFile(self, path, exceptions):
        pass

class FileChecker(PathProcessor):
    toolPath = None
    toolArgs = None

    def __init__(self, toolPath, toolArgs = ""):
        self.toolPath = toolPath
        self.toolArgs = toolArgs

    def processFile(self, path, exceptions):
        shallBeAvoided = False
        if exceptions != None:
            for e in exceptions:
                shallBeAvoided = shallBeAvoided or (re.match(e, path) != None)
        if not shallBeAvoided:
            command = "{0} {1} {2}".format(self.toolPath, self.toolArgs, path)
            print command
        p = subprocess.Popen(command, shell=True, cwd=os.path.dirname(os.path.realpath(self.toolPath)))
        p.communicate()
        if p.returncode != 0:
            raise RuntimeError("Error when executing {0}".format(self.toolPath))

class FileFormatter(PathProcessor):
    toolPath = None
    toolArgs = None

    def __init__(self, toolPath, toolArgs):
        self.toolPath = toolPath
        self.toolArgs = toolArgs

    def processFile(self, path, exceptions):
        shallBeAvoided = False
        if exceptions != None:
            for e in exceptions:
                shallBeAvoided = shallBeAvoided or (re.match(e, path) != None)
        if not shallBeAvoided:
            if os.path.isfile(path):
                command = "{0} {1} {2}".format(self.toolPath, self.toolArgs, path)
                print command
                p = subprocess.Popen(command, shell=True, cwd=os.path.dirname(os.path.realpath(self.toolPath)))
                p.communicate()
                if p.returncode != 0:
                    raise RuntimeError("Error when executing {0}".format(self.toolPath))
            else:
                raise RuntimeError("{0} is not a file".format(path))

class CmdLine(object):
    @staticmethod
    def parseArgs(rawArgs):
        # Create main parser
        parser = argparse.ArgumentParser(prog="codebeautifer", description='Helper for cpplint and astyle.')
        rootSubparsers = parser.add_subparsers(dest="function")

        formatParser = rootSubparsers.add_parser('format', help='Format files')
        formatParser.add_argument('--clang-format', '-c', help='Path to clang-format', action="store_const", const="clang-format")
        formatParser.add_argument('--astyle', '-a', help='Path to astyle', action='store_const', const="astyle")
        formatParser.add_argument('--line-length', "-l", help='Line length', type=int, default=120)
        formatParser.add_argument("targets", type=str, nargs="+", metavar="files or directories")
        formatParser.add_argument("--exceptions", "-e", type=str, nargs="*", metavar="Files or directories not beeing processed (regex is supported)")

        checkParser = rootSubparsers.add_parser('check', help='Check files')
        checkParser.add_argument('--cpplint', '-c', help='Path to cpplint', action='store_const', const="cpplint")
        checkParser.add_argument('--pylint', '-p', help='Path to pylint', action='store_const', const="pylint")
        checkParser.add_argument('--line-length', "-l", help='Line length', type=int, default=120)
        checkParser.add_argument("targets", type=str, nargs="+", metavar="files or directories")
        checkParser.add_argument("--exceptions", "-e", type=str, nargs="*", metavar="Files or directories not beeing processed (regex is supported)", default=None)

        return parser.parse_args(rawArgs[1:])

if __name__ == "__main__":
    try:
        args = CmdLine.parseArgs(sys.argv)

        # Format option
        if args.function == "format":
            # --clang-format and --astyle cannot be used together
            if args.astyle != None and args.clang_format != None:
                raise Exception("--astyle and --clang-format cannot not be used together")

            # Use clang-format by default if nothing is specified
            if args.astyle is None:
                l = searchProgram(r"clang-format-[1-9]\.[0-9]|^clang-format$")
                if len(l) == 0:
                    raise Exception("clang-format is not present in your PATH")
                args.clang_format = l[0]
                print "Using {0}...".format(args.clang_format)
                formatter = FileFormatter(args.clang_format,
                                          "-i -style=\"{{BasedOnStyle: Google, ColumnLimit: {0}}}\"".format(args.line_length))

            # Format with astyle
            else:
                res = distutils.spawn.find_executable(args.astyle)
                if res is None:
                    raise Exception("Unable to find {0}".format(args.astyle))
                else:
                    formatter = FileFormatter(args.astyle,
                                              "--style=google --max-code-length={0} -n".format(args.line_length))

            for p in args.targets:
                formatter.processPath(p, args.exceptions)

        # Check option
        elif args.function == "check":

            # --cpplint and --pylint cannot be used together
            if args.cpplint != None and args.pylint != None:
                raise Exception("--cpplint and --pylint cannot be used together")

            # Use cpplint by default
            if args.pylint is None:
                res = distutils.spawn.find_executable(args.cpplint)
                if res is None:
                    raise Exception("Unable to find {0}".format(args.cpplint))
                checker = FileChecker(args.cpplint,
                                      "--linelength={0} --filter=-whitespace/indent,-build/c++11,-runtime/references".format(args.line_length))

            # Check with pylint
            else:
                res = distutils.spawn.find_executable(args.pylint)
                if res is None:
                    raise Exception("Unable to find {0}".format(args.pylint))
                checker = FileChecker(args.pylint)

            for p in args.targets:
                checker.processPath(p, args.exceptions)
        else:
            sys.exit("An error occured: Unknown action to perform")
        sys.exit()
    except Exception as e:
        sys.exit("An error occured: {0}".format(e))

