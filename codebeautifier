#!/usr/bin/env python
"""codebeautifier

This module is a helper to enforce Ercom's coding style for
different languages (currently C++ and python).

It allows manipulation of tools that do coding style checking
(cpplint, pylint) as well as code
formatter (clang-format, astyle)

"""

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
from abc import abstractmethod


def search_program(match):
    """Searches a program in the system PATH that matches a
    provided regex

    ARGS:
        match (str): Regex to match a program name

    Returns:
        list: The list of candidates
    """

    regex = re.compile(match)
    paths = os.getenv("PATH").split(":")
    candidates = []
    visited = {}

    # For all directories in $PATH
    for path in paths:
        if os.path.isdir(path):
            # For all files in a subdirectory
            for afile in os.listdir(path):
                absfile = os.path.join(path, afile)
                # Directory was not visited before
                if not absfile in visited:
                    # File in directory is an executable file
                    if os.path.isfile(absfile) and os.access(absfile, os.X_OK):
                        # It fulfills the regex
                        if regex.match(afile) != None:
                            candidates.append(absfile)
                    # Mark the directory to visit it only once
                    visited[absfile] = True

    return candidates


class PathProcessor(object):
    """Allows to do path walking and execute specified
    actions while doing so
    """

    def process_path(self, path, exceptions):
        """Iterates over a path to determine whether it must
        be processed as a directory or as a file

        ARGS:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """

        if os.path.isdir(path):
            self.process_dir(os.path.abspath(path), exceptions)
        else:
            self.process_file(os.path.abspath(path), exceptions)

    def process_dir(self, path, exceptions):
        """Iterates over a directory

        ARGS:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if os.path.isdir(path):
                lst = os.listdir(path)
                for pth in lst:
                    folder = os.path.join(path, pth)
                    if os.path.isdir(folder):
                        self.process_dir(folder, exceptions)
                    else:
                        self.process_file(folder, exceptions)
            else:
                raise RuntimeError("'{0}' is not a directory".format(p))

    @abstractmethod
    def process_file(self, path, exceptions):
        """Action to be executed when processing a file
        This method aims at being overloaded by a subclass

        ARGS:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        pass

class FileChecker(PathProcessor):
    """Helper to lint files by linting programs
    """
    tool_path = None
    tool_args = None

    def __init__(self, tool_path, tool_args=""):
        self.tool_path = tool_path
        self.tool_args = tool_args

    def process_file(self, path, exceptions):
        """Action to be done on a file by a linting program

        ARGS:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            command = "{0} {1} {2}".format(self.tool_path, self.tool_args, path)
            print command
            proc = subprocess.Popen(command, shell=True,
                                    cwd=os.path.dirname(
                                        os.path.realpath(self.tool_path)))
            proc.communicate()
            if proc.returncode != 0:
                raise RuntimeError("Error when executing {0}".format(
                    self.tool_path))

class FileFormatter(PathProcessor):
    """Helper to format files by code formatter programs
    """
    tool_path = None
    tool_args = None

    def __init__(self, tool_path, tool_args):
        self.tool_path = tool_path
        self.tool_args = tool_args

    def process_file(self, path, exceptions):
        """Action to be done on a file by a linting program

        ARGS:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if os.path.isfile(path):
                command = "{0} {1} {2}".format(self.tool_path,
                                               self.tool_args, path)
                print command
                proc = subprocess.Popen(command, shell=True,
                                        cwd=os.path.dirname(
                                            os.path.realpath(self.tool_path)))
                proc.communicate()
                if proc.returncode != 0:
                    raise RuntimeError(
                        "Error when executing {0}".format(self.tool_path))
            else:
                raise RuntimeError("{0} is not a file".format(path))


def parse_args(raw_args):
    """Parse command-line arguments and returns the parser

    ARGS:
        raw_args (list): The list program arguments

    Returns:
        The parser fully set
    """

    # Create main parser
    parser = argparse.ArgumentParser(prog="codebeautifer",
                                     description='Coding style helper')
    root_subparser = parser.add_subparsers(dest="function")

    # FORMAT
    format_parser = root_subparser.add_parser('format', help='Format files')
    format_parser.add_argument('--clang-format', '-c',
                               help='Path to clang-format',
                               action="store_const", const="clang-format")
    format_parser.add_argument('--astyle', '-a', help='Path to astyle',
                               action='store_const', const="astyle")
    format_parser.add_argument('--line-length', "-l", help='Line length',
                               type=int, default=120)
    format_parser.add_argument("targets", type=str, nargs="+",
                               metavar="files or directories")
    format_parser.add_argument("--exceptions", "-e", type=str, nargs="*",
                               metavar="Unprocessed paths")

    # CHECK
    check_parser = root_subparser.add_parser('check', help='Check files')
    check_parser.add_argument('--cpplint', '-c', help='Path to cpplint',
                              action='store_const', const="cpplint")
    check_parser.add_argument('--pylint', '-p', help='Path to pylint',
                              action='store_const', const="pylint")
    check_parser.add_argument('--line-length', "-l", help='Line length',
                              type=int, default=120)
    check_parser.add_argument("targets", type=str, nargs="+",
                              metavar="files or directories")
    check_parser.add_argument("--exceptions", "-e", type=str, nargs="*",
                              metavar="Unprocessed paths")

    return parser.parse_args(raw_args[1:])

if __name__ == "__main__":
    try:
        ARGS = parse_args(sys.argv)

        # Format option
        if ARGS.function == "format":
            # --clang-format and --astyle cannot be used together
            if ARGS.astyle != None and ARGS.clang_format != None:
                raise RuntimeError("--astyle and --clang-format cannot not be" \
                                " used together")

            # Use clang-format by default if nothing is specified
            if ARGS.astyle is None:
                L = search_program(r"clang-format-[1-9]\.[0-9]|^clang-format$")
                if len(L) == 0:
                    raise RuntimeError("clang-format is not present " \
                                       "in your PATH")
                ARGS.clang_format = L[0]
                print "Using {0}...".format(ARGS.clang_format)
                FORMATTER = FileFormatter(ARGS.clang_format,
                                          "-i -style=\"{{BasedOnStyle: Google" \
                                          ", ColumnLimit: {0}}}\"".format(
                                              ARGS.line_length))

            # Format with astyle
            else:
                RES = distutils.spawn.find_executable(ARGS.astyle)
                if RES is None:
                    raise RuntimeError("Unable to find {0}".format(ARGS.astyle))
                else:
                    FORMATTER = FileFormatter(ARGS.astyle,
                                              "--style=google " \
                                              "--max-code-length={0} -n".format(
                                                  ARGS.line_length))

            for p in ARGS.targets:
                FORMATTER.process_path(p, ARGS.exceptions)

        # Check option
        elif ARGS.function == "check":

            # --cpplint and --pylint cannot be used together
            if ARGS.cpplint != None and ARGS.pylint != None:
                raise RuntimeError("--cpplint and --pylint cannot " \
                                "be used together")

            # Use cpplint by default
            if ARGS.pylint is None:
                RES = distutils.spawn.find_executable(ARGS.cpplint)
                if RES is None:
                    raise RuntimeError("Unable to find {0}".format(
                        ARGS.cpplint))

                CHECKER = FileChecker(ARGS.cpplint,
                                      "--linelength={0} " \
                                      "--filter=-whitespace/indent," \
                                      "-build/c++11,-runtime/references".format(
                                          ARGS.line_length))

            # Check with pylint
            else:
                RES = distutils.spawn.find_executable(ARGS.pylint)
                if RES is None:
                    raise RuntimeError("Unable to find {0}".format(ARGS.pylint))
                CHECKER = FileChecker(ARGS.pylint)

            for p in ARGS.targets:
                CHECKER.process_path(p, ARGS.exceptions)
        else:
            sys.exit("An error occured: Unknown action to perform")
        sys.exit()
    except RuntimeError as exception:
        sys.exit("An error occured: {0}".format(exception))

