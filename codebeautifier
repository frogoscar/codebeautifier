#!/usr/bin/env python
"""codebeautifier

This module is a helper to enforce Ercom's coding style for
different languages (currently C++ and python).

It allows manipulation of tools that do coding style checking
(cpplint, pylint) as well as code
formatter (clang-format, astyle)

"""

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
from abc import abstractmethod


def searchProgram(match):
    """Searches a program in the system PATH that matches a
    provided regex

    Args:
        match (str): Regex to match a program name

    Returns:
        list: The list of candidates
    """

    regex = re.compile(match)
    paths = os.getenv("PATH").split(":")
    candidates = []
    visited = {}

    # For all directories in $PATH
    for p in paths:
        if os.path.isdir(p):
            # For all files in a subdirectory
            for f in os.listdir(p):
                absfile = os.path.join(p, f)
                # Directory was not visited before
                if not absfile in visited:
                    # File in directory is an executable file
                    if os.path.isfile(absfile) and os.access(absfile, os.X_OK):
                        # It fulfills the regex
                        if regex.match(f) != None:
                            candidates.append(absfile)
                    # Mark the directory to visit it only once
                    visited[absfile] = True

    return candidates


class PathProcessor(object):
    """Allows to do path walking and execute specified
    actions while doing so
    """

    def processPath(self, path, exceptions):
        """Iterates over a path to determine whether it must
        be processed as a directory or as a file

        Args:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """

        if os.path.isdir(path):
            self.processDir(os.path.abspath(path), exceptions)
        else:
            self.processFile(os.path.abspath(path), exceptions)

    def processDir(self, path, exceptions):
        """Iterates over a directory

        Args:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        shallBeAvoided = False
        if exceptions != None:
            for e in exceptions:
                shallBeAvoided = shallBeAvoided or (re.match(e, path) != None)
        if not shallBeAvoided:
            if os.path.isdir(path):
                lst = os.listdir(path)
                for p in lst:
                    folder = os.path.join(path, p)
                    if os.path.isdir(folder):
                        self.processDir(folder, exceptions)
                    else:
                        self.processFile(folder, exceptions)
            else:
                raise RuntimeError("'{0}' is not a directory".format(p))

    @abstractmethod
    def processFile(self, path, exceptions):
        """Action to be executed when processing a file
        This method aims at being overloaded by a subclass

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        pass

class FileChecker(PathProcessor):
    """Helper to lint files by linting programs
    """
    toolPath = None
    toolArgs = None

    def __init__(self, toolPath, toolArgs=""):
        self.toolPath = toolPath
        self.toolArgs = toolArgs

    def processFile(self, path, exceptions):
        """Action to be done on a file by a linting program

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        shallBeAvoided = False
        if exceptions != None:
            for e in exceptions:
                shallBeAvoided = shallBeAvoided or (re.match(e, path) != None)
        if not shallBeAvoided:
            command = "{0} {1} {2}".format(self.toolPath, self.toolArgs, path)
            print command
            p = subprocess.Popen(command, shell=True,
                                 cwd=os.path.dirname(
                                     os.path.realpath(self.toolPath)))
            p.communicate()
            if p.returncode != 0:
                raise RuntimeError("Error when executing {0}".format(
                    self.toolPath))

class FileFormatter(PathProcessor):
    """Helper to format files by code formatter programs
    """
    toolPath = None
    toolArgs = None

    def __init__(self, toolPath, toolArgs):
        self.toolPath = toolPath
        self.toolArgs = toolArgs

    def processFile(self, path, exceptions):
        """Action to be done on a file by a linting program

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        shallBeAvoided = False
        if exceptions != None:
            for e in exceptions:
                shallBeAvoided = shallBeAvoided or (re.match(e, path) != None)
        if not shallBeAvoided:
            if os.path.isfile(path):
                command = "{0} {1} {2}".format(self.toolPath,
                                               self.toolArgs, path)
                print command
                p = subprocess.Popen(command, shell=True,
                                     cwd=os.path.dirname(
                                         os.path.realpath(self.toolPath)))
                p.communicate()
                if p.returncode != 0:
                    raise RuntimeError(
                        "Error when executing {0}".format(self.toolPath))
            else:
                raise RuntimeError("{0} is not a file".format(path))


def parseArgs(rawArgs):
    """Parse command-line arguments and returns the parser

    Args:
        rawArgs (list): The list program arguments

    Returns:
        The parser fully set
    """

    # Create main parser
    parser = argparse.ArgumentParser(prog="codebeautifer",
                                     description='Coding style helper')
    rootSubparsers = parser.add_subparsers(dest="function")

    # FORMAT
    formatParser = rootSubparsers.add_parser('format', help='Format files')
    formatParser.add_argument('--clang-format', '-c',
                              help='Path to clang-format',
                              action="store_const", const="clang-format")
    formatParser.add_argument('--astyle', '-a', help='Path to astyle',
                              action='store_const', const="astyle")
    formatParser.add_argument('--line-length', "-l", help='Line length',
                              type=int, default=120)
    formatParser.add_argument("targets", type=str, nargs="+",
                              metavar="files or directories")
    formatParser.add_argument("--exceptions", "-e", type=str, nargs="*",
                              metavar="Unprocessed paths")

    # CHECK
    checkParser = rootSubparsers.add_parser('check', help='Check files')
    checkParser.add_argument('--cpplint', '-c', help='Path to cpplint',
                             action='store_const', const="cpplint")
    checkParser.add_argument('--pylint', '-p', help='Path to pylint',
                             action='store_const', const="pylint")
    checkParser.add_argument('--line-length', "-l", help='Line length',
                             type=int, default=120)
    checkParser.add_argument("targets", type=str, nargs="+",
                             metavar="files or directories")
    checkParser.add_argument("--exceptions", "-e", type=str, nargs="*",
                             metavar="Unprocessed paths")

    return parser.parse_args(rawArgs[1:])

if __name__ == "__main__":
    try:
        args = parseArgs(sys.argv)

        # Format option
        if args.function == "format":
            # --clang-format and --astyle cannot be used together
            if args.astyle != None and args.clang_format != None:
                raise Exception("--astyle and --clang-format cannot not be" \
                                " used together")

            # Use clang-format by default if nothing is specified
            if args.astyle is None:
                l = searchProgram(r"clang-format-[1-9]\.[0-9]|^clang-format$")
                if len(l) == 0:
                    raise Exception("clang-format is not present in your PATH")
                args.clang_format = l[0]
                print "Using {0}...".format(args.clang_format)
                formatter = FileFormatter(args.clang_format,
                                          "-i -style=\"{{BasedOnStyle: Google" \
                                          " ColumnLimit: {0}}}\"".format(
                                              args.line_length))

            # Format with astyle
            else:
                res = distutils.spawn.find_executable(args.astyle)
                if res is None:
                    raise Exception("Unable to find {0}".format(args.astyle))
                else:
                    formatter = FileFormatter(args.astyle,
                                              "--style=google " \
                                              "--max-code-length={0} -n".format(
                                                  args.line_length))

            for p in args.targets:
                formatter.processPath(p, args.exceptions)

        # Check option
        elif args.function == "check":

            # --cpplint and --pylint cannot be used together
            if args.cpplint != None and args.pylint != None:
                raise Exception("--cpplint and --pylint cannot " \
                                "be used together")

            # Use cpplint by default
            if args.pylint is None:
                res = distutils.spawn.find_executable(args.cpplint)
                if res is None:
                    raise Exception("Unable to find {0}".format(args.cpplint))

                checker = FileChecker(args.cpplint,
                                      "--linelength={0} " \
                                      "--filter=-whitespace/indent," \
                                      "-build/c++11,-runtime/references".format(
                                          args.line_length))

            # Check with pylint
            else:
                res = distutils.spawn.find_executable(args.pylint)
                if res is None:
                    raise Exception("Unable to find {0}".format(args.pylint))
                checker = FileChecker(args.pylint)

            for p in args.targets:
                checker.processPath(p, args.exceptions)
        else:
            sys.exit("An error occured: Unknown action to perform")
        sys.exit()
    except Exception as e:
        sys.exit("An error occured: {0}".format(e))

