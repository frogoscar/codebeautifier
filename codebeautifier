#! /usr/bin/env python3
#
# Copyright (c) 2015 Ercom
#
# Authors:
#   - Alexandre Acebedo <alexandre.acebedo@ercom.fr>
#   - Jean Guyomarc'h <jean.guyomarch-serv@ercom.fr>
#

"""Codebeautifier

Helper to use linters and formatters.
Currently supported:
 - Python:
   - pylint
   - pylint3
   - autopep8
 - C++:
   - astyle
   - clang-format
   - cpplint
 - Java
   - checkstyle
   - astyle
"""

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
import logging
from colorlog import ColoredFormatter
from abc import abstractmethod
from enum import IntEnum, unique




class Tool(object):
    """Wrapper to execute a program-line tool.

    Commands to be used must respect the convention:
        <tool> [options] <target>
    """

    class ToolId(IntEnum):
        """Identifiers for the tools used by Codebeautifier"""
        CLANG_FORMAT = 1
        ASTYLE = 2
        CPPLINT = 3
        PYLINT2 = 4
        PYLINT3 = 5
        CHECKSTYLE = 6
        AUTOPEP8 = 7

    # pylint: disable=too-few-public-methods
    class Filter(object):
        """
        Parses the outputs and result of a command to determine
        the failure of its execution
        """
        # pylint: disable=no-self-use
        def filter_command(self, retcode, dummy_stdout, dummy_stderr):
            """Basic filtering function

            Args:
                retcode (int): The exit status of the program
                stdout (str): What was printed in stdout
                stderr (str): What was printed in stderr

            Returns: True if the command has succeeded, False otherwise
            """
            return retcode is 0

    # pylint: disable=too-few-public-methods
    class CheckstyleFilter(Filter):
        """
        Parses the outputs and result of checkstyle to determine
        the failure of its execution
        """
        def filter_command(self, retcode, stdout, stderr):
            """
            Parses the output of checkstyle to determine
            the failure of its execution

            Args:
                retcode (int): The exit status of checkstyle
                stdout (str): What was printed in stdout
                stderr (str): What was printed in stderr
            """
            if super().filter_command(retcode, stdout, stderr):
                if stdout.find(': warning: ') is -1:
                    return True
            return False


    # pylint: disable=too-many-arguments
    def __init__(self, identifier, program,
                 common_arguments=None, quiet=False,
                 command_filter=None):
        self.program = program
        self.quiet = quiet
        self.identifier = identifier
        if common_arguments is None:
            common_arguments = []
        if command_filter is None:
            command_filter = Tool.Filter()

        self.common_arguments = common_arguments
        self.command_filter = command_filter

    def execute(self, target, arguments=None):
        """Launches the program on a specified target

        Args:
            target (str): target of the program
        """
        if arguments is None:
            arguments = []
        command = [self.program] + self.common_arguments +  arguments + [target]
        CodeBeautifier.logger.info(command)
        proc = subprocess.Popen(command, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        out, err = proc.communicate()
        out = out.decode('UTF-8')
        err = err.decode('UTF-8')

        if self.quiet is False:
            if out:
                print("STDOUT:\n", out)
            if err:
                print("STDERR:\n", err)
        if self.command_filter.filter_command(
                proc.returncode, out, err) is False:
            CodeBeautifier.status = -1
            raise RuntimeError(
                "\"{0}\" does not respect coding rules. Please run "
                "\"codebeautifier format {0}\" to correct the issues"
                .format(target))

    def get_id(self):
        """Gets the identifier of the processing tool

        Args:
            identifier (ToolId) identifier of the processing tool
        """
        return self.identifier


class FileProcessor(object):
    """Infrastructure to determine the programming language used in a file
    """
    @unique
    class Status(IntEnum):
        """Error codes used when checking the language of a file"""
        no_extension = 1
        no_shebang = 2
        invalid_extension = 3
        invalid_shebang = 4
        invalid_file = 5
        unhandled_mimetype = 6

        def __str__(self):
            err = {
                FileProcessor.Status.no_extension:       'No Extension',
                FileProcessor.Status.no_shebang:         'No Shebang',
                FileProcessor.Status.invalid_extension:  'Invalid Extension',
                FileProcessor.Status.invalid_shebang:    'Invalid Shebang',
                FileProcessor.Status.invalid_file:       'Invalid File',
                FileProcessor.Status.unhandled_mimetype: 'Unhandled Mime Type'
            }
            return "{0}".format(err[self.value])

        @staticmethod
        def list_to_string(status_list):
            """Generates a message from a list of status for debugging purposes

            Args:
                status_list (list): A list of status

            Returns: A human-readable message
            """
            msg = ''
            for index, status in enumerate(status_list):
                msg += str(status)
                if index is not len(status_list) - 1:
                    msg += ', '
            return msg


    def __init__(self, file_shebang_regex=None):
        self.formatter = None
        self.checker = None
        self.file_shebang_regex = file_shebang_regex
        self.file_program = distutils.spawn.find_executable('file')
        if self.file_program is None:
            CodeBeautifier.logger.warning("file binary was not found")

    def shall_process(self, filename):
        """Apply a language shall_process on the provided filename

        Args:
            filename (str): The filename to be checked

        Returns:
            A list of errors
        """
        # pylint: disable=no-self-use
        if os.path.isfile(filename):
            return []
        else:
            return [FileProcessor.Status.invalid_file]

    @staticmethod
    def check_extension(filename, extensions):
        """Checks the extension of a file among possible extensions

        Args:
            filename (str): The filename to be checked
            extensions (list): List of supported extensions

        Returns:
            Status (ok, no extension, unsupported)
        """
        assert filename is not None
        assert extensions is not None

        ext = CodeBeautifier.get_extension(filename)
        if ext is None:
            return [FileProcessor.Status.no_extension]
        elif ext in extensions:
            return []
        else:
            return [FileProcessor.Status.invalid_extension]

    @staticmethod
    def check_shebang(filename, shebang_regex):
        """Checks the shebang of a file among possible shebangs

        Args:
            filename (str): The filename to be checked
            shebang (regex): Allowed shebangs

        Returns:
            Status (ok, no shebang, invalid)
        """
        assert filename is not None
        assert shebang_regex is not None

        shebang = CodeBeautifier.get_shebang(filename)
        if shebang is None:
            return [FileProcessor.Status.no_shebang]
        else:
            regex = re.compile(shebang_regex)
            if regex.match(shebang):
                return []
            else:
                return [FileProcessor.Status.invalid_shebang]

    @abstractmethod
    def get_processed_language(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        pass

    def format_file(self, filepath):
        """Use the Tool provided to the FileProcessor to
           format a file

        Args:
            filepath (str): path of the file to be formatted
        """
        if self.formatter is not None:
            self.formatter.execute(filepath)
        else:
            raise RuntimeError(
                "No formatter available for {0}".format(
                    self.get_processed_language))

    def check_file(self, filepath):
        """Use the Tool provided to the FileProcessor to
           check a file

        Args:
            filepath (str): path of the file to be checked
        """
        if self.checker is not None:
            self.checker.execute(filepath)
        else:
            raise RuntimeError(
                "{0} cannot be processed (No checker available for {1})"
                .format(filepath,
                        self.get_processed_language()))

    def check_mime_type(self, filename):
        """Check if the filename mime type's is supported

        Args:
            filename (str): file to be analysed

        Returns: True if the mime type is supported.
                 False otherwise.
        """
        ret = []
        if self.file_program is not None:
            proc = subprocess.Popen([self.file_program,
                                     '--mime-type',
                                     '--brief',
                                     filename],
                                    stdout=subprocess.PIPE)
            out = proc.communicate()[0].decode('UTF-8').rstrip()
            if proc.returncode is 0:
                if not out in self.get_mime_types():
                    ret = [FileProcessor.Status.unhandled_mimetype]
        return ret

    def can_check_mime_type(self):
        """Returns if the FileProcessor is able to check for mime types
        """
        return self.file_program is not None

    @abstractmethod
    def get_extensions(self):
        """Returns: the extensions supported by a language
        """
        pass

    @abstractmethod
    def get_mime_types(self):
        """Returns: mime types handled
        """
        pass


class CppFileProcessor(FileProcessor):
    """Checker for C++"""

    def get_extensions(self):
        return [".cc", ".cpp", ".cxx", ".hh", ".hpp", ".hxx", ".h"]

    def get_mime_types(self):
        return ["text/x-c++"]

    def __init__(self, tools=None):
        super().__init__()
        if tools is None:
            tools = []
        for tool in tools:
            if tool.get_id() == Tool.ToolId.CPPLINT:
                self.checker = tool
                break

        for tool in tools:
            if tool.get_id() == Tool.ToolId.CLANG_FORMAT:
                self.formatter = tool
                break

        if self.formatter is None:
            for tool in tools:
                if tool.get_id() == Tool.ToolId.ASTYLE:
                    self.formatter = tool
                    break

    def get_processed_language(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'cpp'

    def shall_process(self, filename):
        return super().shall_process(filename) + \
            FileProcessor.check_extension(
                filename, self.get_extensions())

class Python2FileProcessor(FileProcessor):
    """Checker for Python 2"""

    def get_extensions(self):
        return [".py"]

    def get_mime_types(self):
        return ["text/x-python"]

    def __init__(self, tools):
        super().__init__()
        for tool in tools:
            if tool.get_id() is Tool.ToolId.PYLINT2:
                self.checker = tool
                break

        for tool in tools:
            if tool.get_id() is Tool.ToolId.AUTOPEP8:
                self.formatter = tool
                break
        self.shebang_regex = re.compile(
            r"^(\#\!)(\s*)/usr/bin/env(\s*)python2.*$")

    def get_processed_language(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'python2'

    def shall_process(self, filename):
        ret = []
        ret_ext = FileProcessor.check_extension(
            filename, self.get_extensions())
        if len(ret_ext) != 0:
            ret_sbg = FileProcessor.check_shebang(filename, self.shebang_regex)
            if len(ret_sbg) != 0:
                ret = ret_ext + ret_sbg
        return ret


class Python3FileProcessor(FileProcessor):
    """Checker for Python 3"""

    def get_extensions(self):
        return [".py"]

    def get_mime_types(self):
        return ["text/x-python"]

    def __init__(self, tools):
        super().__init__()
        for tool in tools:
            if tool.get_id() is Tool.ToolId.PYLINT3:
                self.checker = tool
                break

        for tool in tools:
            if tool.get_id() is Tool.ToolId.AUTOPEP8:
                self.formatter = tool
                break
        self.shebang_regex = re.compile(
            r"^(\#\!)(\s*)/usr/bin/env(\s*)python3.*$")

    def get_processed_language(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'python3'

    def shall_process(self, filename):
        ret = []
        ret_ext = FileProcessor.check_extension(
            filename, self.get_extensions())
        if len(ret_ext) != 0:
            ret_sbg = FileProcessor.check_shebang(filename, self.shebang_regex)
            if len(ret_sbg) != 0:
                ret = ret_ext + ret_sbg
        return ret


class JavaFileProcessor(FileProcessor):
    """Checker for Java"""

    def get_extensions(self):
        return [".java"]

    def get_mime_types(self):
        return ["text/x-java-source,java"]

    def __init__(self, tools=None):
        super().__init__()
        if tools is None:
            tools = []
        for tool in tools:
            if tool.get_id() is Tool.ToolId.CHECKSTYLE:
                self.checker = tool
                break
        for tool in tools:
            if tool.get_id() is Tool.ToolId.ASTYLE:
                self.formatter = tool
                break

    def get_processed_language(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'java'

    def shall_process(self, filename):
        return super().shall_process(filename) + \
            FileProcessor.check_extension(
                filename, self.get_extensions())


class CodeBeautifier(object):
    """CodeBeautifier utilities"""

    logger = None
    status = 0

    @staticmethod
    def logger_init(level):
        """Initializes the logger

        Args:
            level: The log level of the logger to be initialized
        """

        formatter = ColoredFormatter(
            "%(log_color)s[%(levelname)-8s]%(reset)s %(message)s",
            datefmt=None,
            reset=True,
            log_colors={
                'DEBUG': 'cyan',
                'INFO': 'green',
                'WARNING': 'yellow',
                'ERROR': 'red',
                'CRITICAL': 'bold_red'
            })
        handler = logging.StreamHandler()
        handler.setFormatter(formatter)
        CodeBeautifier.logger = logging.getLogger("codebeautifier")
        CodeBeautifier.logger.addHandler(handler)
        CodeBeautifier.logger.setLevel(level)

    @staticmethod
    def search_program(match):
        """Searches a program in the system PATH that matches a
        provided regex

        Args:
            match (str): Regex to match a program name

        Returns:
            list: The list of candidates
        """

        regex = re.compile(match)
        paths = os.getenv("PATH").split(":")
        candidates = []
        visited = {}

        # For all directories in $PATH
        for path in paths:
            if os.path.isdir(path):
                # For all files in a subdirectory
                for afile in os.listdir(path):
                    absfile = os.path.join(path, afile)
                    # Directory was not visited before
                    if not absfile in visited:
                        # File in directory is an executable file
                        if os.path.isfile(absfile) and os.access(absfile,
                                                                 os.X_OK):
                            # It fulfills the regex
                            if regex.match(afile) != None:
                                candidates.append(absfile)
                        # Mark the directory to visit it only once
                        visited[absfile] = True

        return candidates


    @staticmethod
    def get_extension(filename):
        """Returns the extension of a file
        """
        return os.path.splitext(filename)[1]


    @staticmethod
    def get_shebang(filename):
        """Gets the shebang of a script.
        It must be formatted as specified in IEEE POSIX.1-2008

        Args:
            filename (str): The file to examine

        Returns:
            The shebang. None if it could not be retrieved.
        """
        try:
            with open(filename, 'r') as fhdl:
                line = fhdl.readline()
                if len(line) > 2 and line[0] == '#' and line[1] == '!':
                    return line
        except UnicodeDecodeError:
            CodeBeautifier.logger.error(
                "Fail to read from \"" + filename + "\"")
        return None

    # pylint: disable=too-many-branches
    @staticmethod
    def process_file(filename, processors, strict, ignores, func):
        """Execute commands on a file

        Args:
            filename (str): Name of the file to be processed
            commands_table (dict): list of program for languages
            strict (bool): if True, aborts on error
        """
        try:
            avoid = False
            for ignored in ignores:
                if re.match(ignored, filename) is not None:
                    avoid = True
                    break
            if avoid is True:
                return

            file_processed = None
            mimetype_handled = False
            all_errors = []
            for processor in processors:
                errors = processor.shall_process(filename)
                if len(errors) == 0:
                    func(processor, filename)
                    file_processed = processor.get_processed_language()
                    break
                # Union of the errors
                all_errors = list(set(errors) | set(all_errors))

                # Determine whether mime type was handled or not
                mimetype_err = processor.check_mime_type(filename)
                if not FileProcessor.Status.unhandled_mimetype in mimetype_err:
                    mimetype_handled = True

            if file_processed is not None:
                CodeBeautifier.logger.debug("processed " + filename +
                                            " as " +
                                            file_processed)
            else:
                if not mimetype_handled:
                    all_errors.append(FileProcessor.Status.unhandled_mimetype)
                if strict is True:
                    CodeBeautifier.logger.error(
                        "Fail to process \"{0}\" ({1})".format(
                            filename,
                            FileProcessor.Status.list_to_string(all_errors)
                        )
                    )
                    sys.exit(2)
                else:
                    CodeBeautifier.logger.warning(
                        "\"{0}\" was not processed ({1})".format(
                            filename,
                            FileProcessor.Status.list_to_string(all_errors)
                        )
                    )

        except RuntimeError as exception:
            CodeBeautifier.logger.error("{0}".format(exception))
            if strict is True:
                sys.exit(3)


    @staticmethod
    def parse_args(raw_args):
        """Parse program-line arguments and returns the parser

        Args:
            raw_args (list): The list program arguments

        Returns:
            The parser fully set
        """

        # Create main parser
        parser = argparse.ArgumentParser(prog="codebeautifer",
                                         description='Coding style helper')
        parser.add_argument('--verbose', '-v', action='store_true')
        parser.add_argument('--quiet', '-q', action='store_true')
        root_subparser = parser.add_subparsers(dest="function")

        # FORMAT
        format_parser = root_subparser.add_parser('format', help='Format files')
        format_parser.add_argument('--clang-format', '-c',
                                   help='Path to clang-format',
                                   type=str, default=None)
        format_parser.add_argument('--autopep8', '-A', help='Path to autopep8',
                                   type=str, default="autopep8")
        format_parser.add_argument('--astyle', '-a', help='Path to astyle',
                                   type=str, default="astyle")
        format_parser.add_argument('--line-length', "-l", help='Line length',
                                   type=int, default=80)
        format_parser.add_argument("targets", type=str, nargs="+",
                                   metavar="files or directories")
        format_parser.add_argument("--ignored-paths", "-e", type=str, nargs="*",
                                   metavar="Unprocessed paths")
        format_parser.add_argument("--strict", "-S", action='store_true')

        # CHECK
        check_parser = root_subparser.add_parser('check', help='Check files')
        check_parser.add_argument('--line-length', "-l", help='Line length',
                                  type=int, default=80)
        check_parser.add_argument('--cpplint', '-c', help='Path to cpplint',
                                  type=str, default="cpplint")
        check_parser.add_argument('--pylint2', '-p2', help='Path to pylint2',
                                  type=str, default="pylint")
        check_parser.add_argument('--pylint3', '-p3', help='Path to pylint3',
                                  type=str, default="pylint3")
        check_parser.add_argument(
            '--checkstyle', '-C', type=str,
            help='Checkstyle main class or JAR',
            default='com.puppycrawl.tools.checkstyle.CodeBeautifier')
        check_parser.add_argument("targets", type=str, nargs="+",
                                  metavar="files or directories")
        check_parser.add_argument("--ignored-paths", "-e", type=str, nargs="*",
                                  metavar="Unprocessed paths")
        check_parser.add_argument("--strict", "-S", action='store_true')

        return parser.parse_args(raw_args[1:])


    def __init__(self):
        self.tools = []
        self.processors = []
        self.parsed_args = None

    # pylint: disable=too-many-arguments
    def add_tool(self, identifier, command, arguments, quiet, filter_cmd=None):
        """Registers a program in the commands table

        Args:
            program (str): name of the binary to be run
            parsed_args (str): options to forward to the program
            *langs: languages supported by the program
        """

        # Format with astyle
        res = distutils.spawn.find_executable(command)
        if res is None:
            self.logger.info(
                "{0} not found".format(command))
        else:
            self.logger.debug("{0} found".format(command))
            self.tools.append(
                Tool(identifier, res, arguments, quiet, filter_cmd))

    def initialize_processors(self):
        """
        Initializes the file processors. Sets a list of file processors
        for each supported language
        """
        self.processors.append(CppFileProcessor(self.tools))
        self.processors.append(Python2FileProcessor(self.tools))
        self.processors.append(Python3FileProcessor(self.tools))
        self.processors.append(JavaFileProcessor(self.tools))

    def initialize_checkers(self):
        """
        Initializes the file checkers.
        """
        try:
            # Cpplint
            self.add_tool(Tool.ToolId.CPPLINT,
                          self.parsed_args.cpplint, [
                              "--linelength={0}".format(
                                  self.parsed_args.line_length),
                              "--filter=-whitespace/indent,"
                              "-build/c++11,-runtime/references"
                          ], self.parsed_args.quiet)

            # Pylint2
            self.add_tool(Tool.ToolId.PYLINT2,
                          self.parsed_args.pylint2, [
                              "--reports=no",
                              "--disable=locally-disabled"
                          ], self.parsed_args.quiet)

            # Pylint3
            self.add_tool(Tool.ToolId.PYLINT3,
                          self.parsed_args.pylint3, [
                              "--reports=no",
                              "--disable=locally-disabled"
                          ], self.parsed_args.quiet)

            # Checkstyle for Java
            checkstyle_args = []
            if CodeBeautifier.get_extension(
                    self.parsed_args.checkstyle) == '.jar':
                checkstyle_args.append('-jar')
            checkstyle_args.append(self.parsed_args.checkstyle)
            checkstyle_args.append('-c')
            checkstyle_args.append('/google_checks.xml')
            self.add_tool(Tool.ToolId.CHECKSTYLE,
                          "java", checkstyle_args, self.parsed_args.quiet,
                          Tool.CheckstyleFilter())

        except RuntimeError as exception:
            sys.exit("An error occured: {0}".format(exception))

    def initialize_formatters(self):
        """
        Initializes the file checkers.
        """
        try:
            # Clang-format
            ignore_clang = False
            if self.parsed_args.clang_format is None:
                candidates = CodeBeautifier.search_program(
                    r"clang-format-[1-9]\.[0-9]|^clang-format$")
                if len(candidates) == 0:
                    CodeBeautifier.logger.info("clang-format not found")
                    ignore_clang = True
                else:
                    self.parsed_args.clang_format = candidates[0]

            if ignore_clang is False:
                self.add_tool(Tool.ToolId.CLANG_FORMAT,
                              self.parsed_args.clang_format, [
                                  "-i",
                                  "-style",
                                  '{{BasedOnStyle: Google, '
                                  'ColumnLimit: {0}}}'.format(
                                      self.parsed_args.line_length)
                              ], self.parsed_args.quiet)

            self.add_tool(
                Tool.ToolId.ASTYLE, self.parsed_args.astyle, [
                    "--style=google",
                    "--max-code-length={0} -n".format(
                        self.parsed_args.line_length)
                ], self.parsed_args.quiet
            )

            self.add_tool(
                Tool.ToolId.AUTOPEP8, self.parsed_args.autopep8, [
                    "--in-place",
                    "--aggressive"
                ], self.parsed_args.quiet
            )

        except RuntimeError as exception:
            sys.exit("An error occured: {0}".format(exception))

        return self

    def initialize(self, args):
        """Performs the initialization of the main

        Args:
            args: Command-line arguments to be parsed
        """
        self.parsed_args = CodeBeautifier.parse_args(args)
        if self.parsed_args.verbose is True and self.parsed_args.quiet is True:
            raise RuntimeError("--verbose and --quiet cannot be used together")

        log_level = logging.INFO
        if self.parsed_args.verbose is True:
            log_level = logging.DEBUG
        elif self.parsed_args.quiet is True:
            log_level = logging.WARNING
        CodeBeautifier.logger_init(log_level)

        if self.parsed_args.function is None:
            raise AttributeError("Missing positional argument")

        if self.parsed_args.function == "check":
            self.initialize_checkers()
        elif self.parsed_args.function == "format":
            self.initialize_formatters()

        self.initialize_processors()


    def main(self, args):
        """Main entry point of CodeBeautifier

        Args:
            args: command-line arguments to be parsed
        """

        try:
            self.initialize(args)
        except RuntimeError as exception:
            print("*** ERROR: {0}".format(exception))
            return 2
        except AttributeError as exception:
            print("*** ERROR: {0}".format(exception))
            return 2

        ignores = []
        if self.parsed_args.ignored_paths:
            for ign in self.parsed_args.ignored_paths:
                regex = re.compile(ign)
                ignores.append(regex)

        #===
        # Processing
        #===
        func_to_execute = None
        if self.parsed_args.function == "format":
            func_to_execute = lambda x, y: x.format_file(y)
        else:
            func_to_execute = lambda x, y: x.check_file(y)
        for target in self.parsed_args.targets:
            if not os.path.exists(target):
                CodeBeautifier.logger.error(
                    "Cannot process path \"{0}\" because it "
                    "does not exist".format(target))
                if self.parsed_args.strict is True:
                    CodeBeautifier.status = -1
                    break
                else:
                    continue

            # Avoid exceptions
            if os.path.isdir(target):
                for root, _, files in os.walk(target):
                    for afile in files:
                        CodeBeautifier.process_file(
                            root + '/' + afile,
                            self.processors,
                            self.parsed_args.strict, ignores, func_to_execute
                        )
            else:
                CodeBeautifier.process_file(
                    target, self.processors, self.parsed_args.strict,
                    ignores, func_to_execute
                )
        return CodeBeautifier.status

if __name__ == "__main__":
    sys.exit(CodeBeautifier().main(sys.argv))
