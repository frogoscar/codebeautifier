#! /usr/bin/env python3

"""codebeautifier

This module is a helper to enforce Ercom's coding style for
different languages (currently C++ and python).

It allows manipulation of tools that do coding style checking
(cpplint, pylint) as well as code
formatter (clang-format, astyle)

"""

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
from abc import abstractmethod


def search_program(match):
    """Searches a program in the system PATH that matches a
    provided regex

    Args:
        match (str): Regex to match a program name

    Returns:
        list: The list of candidates
    """

    regex = re.compile(match)
    paths = os.getenv("PATH").split(":")
    candidates = []
    visited = {}

    # For all directories in $PATH
    for path in paths:
        if os.path.isdir(path):
            # For all files in a subdirectory
            for afile in os.listdir(path):
                absfile = os.path.join(path, afile)
                # Directory was not visited before
                if not absfile in visited:
                    # File in directory is an executable file
                    if os.path.isfile(absfile) and os.access(absfile, os.X_OK):
                        # It fulfills the regex
                        if regex.match(afile) != None:
                            candidates.append(absfile)
                    # Mark the directory to visit it only once
                    visited[absfile] = True

    return candidates

def get_extension(filename):
    """Returns the extension of a file
    """
    return os.path.splitext(filename)[1]

def log(msg):
    """Decorates prints on standard output

    Args:
        msg: The message to be printed on stdout
    """
    print("-- " + msg)

def get_shebang(filename):
    """Gets the shebang of a script.
    It must be formatted as specified in IEEE POSIX.1-2008

    Args:
        filename (str): The file to examine

    Returns:
        The shebang. None if it could not be retrieved.
    """
    try:
        with open(filename, 'r') as fhdl:
            line = fhdl.readline()
            if len(line) > 2 and line[0] == '#' and line[1] == '!':
                return line
    except UnicodeDecodeError as exception:
        log("Fail to read from \"" + filename + "\"")
    return None


class PathProcessor(object):
    """Allows to do path walking and execute specified
    actions while doing so
    """

    def process_path(self, path, exceptions):
        """Iterates over a path to determine whether it must
        be processed as a directory or as a file

        Args:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """

        if os.path.isdir(path):
            self.process_dir(os.path.abspath(path), exceptions)
        else:
            self.process_file(os.path.abspath(path), exceptions)

    def process_dir(self, path, exceptions):
        """Iterates over a directory

        Args:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if os.path.isdir(path):
                lst = os.listdir(path)
                for pth in lst:
                    folder = os.path.join(path, pth)
                    if os.path.isdir(folder):
                        self.process_dir(folder, exceptions)
                    else:
                        self.process_file(folder, exceptions)
            else:
                raise RuntimeError("'{0}' is not a directory".format(p))

    @abstractmethod
    def process_file(self, path, exceptions):
        """Action to be executed when processing a file
        This method aims at being overloaded by a subclass

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        pass


class FileChecker(PathProcessor):
    """Helper to lint files by linting programs
    """
    tool_path = None
    tool_args = None
    extensions = None
    shebang = None

    def __init__(self, tool_path, extensions, shebang=None, tool_args=""):
        self.tool_path = tool_path
        self.tool_args = tool_args
        self.extensions = extensions
        if shebang is not None:
            self.shebang = re.compile(shebang)

    def process_file(self, path, exceptions):
        """Action to be done on a file by a linting program

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if not os.path.isfile(path):
                raise RuntimeError("{0} is not a file".format(path))

            # Extension/shebang not handled by checker?
            if not get_extension(path) in self.extensions:
                if self.shebang is None:
                    return False
                shebang = get_shebang(path)
                if shebang is None:
                    return False
                if self.shebang.match(shebang) == None:
                    return False

            command = "{0} {1} {2}".format(self.tool_path, self.tool_args, path)
            log(command)
            proc = subprocess.Popen(command, shell=True,
                                    cwd=os.path.dirname(
                                        os.path.realpath(self.tool_path)))
            proc.communicate()
            if proc.returncode != 0:
                raise RuntimeError("Error when executing {0}".format(
                    self.tool_path))

        return True

class FileFormatter(PathProcessor):
    """Helper to format files by code formatter programs
    """
    tool_path = None
    tool_args = None
    extensions = None
    shebang = None

    def __init__(self, tool_path, extensions, shebang=None, tool_args=""):
        self.tool_path = tool_path
        self.tool_args = tool_args
        self.extensions = extensions
        if shebang is not None:
            self.shebang = re.compile(shebang)

    def process_file(self, path, exceptions):
        """Action to be done on a file by a linting program

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.

        Returns:
            True if the file was successfully processed.
            False if the file could not be processed.
            Raises an exception on error
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if not os.path.isfile(path):
                raise RuntimeError("{0} is not a file".format(path))

            # Extension/shebang not handled by checker?
            if not get_extension(path) in self.extensions:
                if self.shebang is None:
                    return False
                shebang = get_shebang(path)
                if not self.shebang.match(shebang):
                    return False

            command = "{0} {1} {2}".format(self.tool_path,
                                           self.tool_args, path)
            log(command)
            proc = subprocess.Popen(command, shell=True,
                                    cwd=os.path.dirname(
                                        os.path.realpath(self.tool_path)))
            proc.communicate()
            if proc.returncode != 0:
                raise RuntimeError(
                    "Error when executing {0}".format(self.tool_path))

        return True

class FileProcessor(PathProcessor):
    """Helper around FileChecker and FileFormatter.
    This class takes as input n formatters/checkers and try them
    all on a file until one suits its input
    """

    processors = None

    def __init__(self, processors):
        self.processors = processors

    def process_file(self, path, exceptions):
        """Iterates through the processors passed to the object.
        It tries the first one. If the processor refuses to process
        the file, the next one is used

        Args:
            path (str): The input file to process
            exceptions (regex): Path not to be processed

        Returns:
            True if the file has been processed.
            False otherwise.
        """
        for proc in self.processors:
            if proc.process_file(path, exceptions):
                return True
        log("Fail to process \"" + path + "\"")
        return False


def parse_args(raw_args):
    """Parse command-line arguments and returns the parser

    Args:
        raw_args (list): The list program arguments

    Returns:
        The parser fully set
    """

    # Create main parser
    parser = argparse.ArgumentParser(prog="codebeautifer",
                                     description='Coding style helper')
    root_subparser = parser.add_subparsers(dest="function")

    # FORMAT
    format_parser = root_subparser.add_parser('format', help='Format files')
    format_parser.add_argument('--clang-format', '-c',
                               help='Path to clang-format',
                               type=str, default=None)
    format_parser.add_argument('--autopep8', '-A', help='Path to autopep8',
                               type=str, default="autopep8")
    format_parser.add_argument('--astyle', '-a', help='Path to astyle',
                               type=str, default="astyle")
    format_parser.add_argument('--line-length', "-l", help='Line length',
                               type=int, default=120)
    format_parser.add_argument("targets", type=str, nargs="+",
                               metavar="files or directories")
    format_parser.add_argument("--exceptions", "-e", type=str, nargs="*",
                               metavar="Unprocessed paths")

    # CHECK
    check_parser = root_subparser.add_parser('check', help='Check files')
    check_parser.add_argument('--cpplint', '-c', help='Path to cpplint',
                              type=str, default="cpplint")
    check_parser.add_argument('--pylint2', '-p2', help='Path to pylint2',
                              type=str, default="pylint")
    check_parser.add_argument('--pylint3', '-p3', help='Path to pylint3',
                              type=str, default="pylint3")
    check_parser.add_argument('--line-length', "-l", help='Line length',
                              type=int, default=120)
    check_parser.add_argument("targets", type=str, nargs="+",
                              metavar="files or directories")
    check_parser.add_argument("--exceptions", "-e", type=str, nargs="*",
                              metavar="Unprocessed paths")

    return parser.parse_args(raw_args[1:])


if __name__ == "__main__":
    try:
        ARGS = parse_args(sys.argv)
        CPP_EXTENSIONS = [".cc", ".cpp", ".cxx", ".hh", ".hpp", ".hxx", ".h"]
        PYTHON_EXTENSIONS = [] # We rely on the shebang only
        PYTHON2_SHEBANG_REGEX = r"^(\#\!).*python2.*"
        PYTHON3_SHEBANG_REGEX = r"^(\#\!).*python3.*"
        PYTHON_SHEBANGS_REGEX = PYTHON2_SHEBANG_REGEX + r"|" + \
                                PYTHON3_SHEBANG_REGEX
        JAVA_EXTENSIONS = [".java"]

        # Format option
        if ARGS.function == "format":
            FORMATTERS = []

            # Clang-format
            CLANG_FOUND = False
            if ARGS.clang_format is None:
                L = search_program(r"clang-format-[1-9]\.[0-9]|^clang-format$")
                if len(L) == 0:
                    log("clang-format not found")
                else:
                    ARGS.clang_format = L[0]
                    CLANG_FOUND = True
            else:
                RES = distutils.spawn.find_executable(ARGS.clang_format)
                if RES is None:
                    log("clang-format ({0}) not found".format(
                        ARGS.clang_format))
                else:
                    CLANG_FOUND = True

            if CLANG_FOUND:
                log("{0} found".format(ARGS.clang_format))
                FORMATTER = FileFormatter(ARGS.clang_format,
                                          CPP_EXTENSIONS,
                                          None,
                                          "-i -style=\"{{BasedOnStyle: Google"\
                                          ", ColumnLimit: {0}}}\"".format(
                                              ARGS.line_length))
                FORMATTERS.append(FORMATTER)

            # Format with astyle
            RES = distutils.spawn.find_executable(ARGS.astyle)
            if RES is None:
                log("astyle ({0}) not found".format(ARGS.astyle))
            else:
                log("{0} found".format(ARGS.astyle))
                FORMATTER = FileFormatter(ARGS.astyle,
                                          CPP_EXTENSIONS,
                                          None,
                                          "--style=google " \
                                          "--max-code-length={0} -n".format(
                                              ARGS.line_length))
                FORMATTERS.append(FORMATTER)

            # Format with autopep8
            RES = distutils.spawn.find_executable(ARGS.autopep8)
            if RES is None:
                log("autopep8 ({0}) not found".format(ARGS.autopep8))
            else:
                log("{0} found".format(ARGS.autopep8))
                FORMATTER = FileFormatter(ARGS.autopep8,
                                          PYTHON_EXTENSIONS,
                                          PYTHON_SHEBANGS_REGEX,
                                          "--in-place --aggressive")
                FORMATTERS.append(FORMATTER)


            if len(FORMATTERS) is 0:
                raise RuntimeError("No FORMATTERS have been detected")

            for p in ARGS.targets:
                FileProcessor(FORMATTERS).process_path(p, ARGS.exceptions)


        # Check option
        elif ARGS.function == "check":
            CHECKERS = []

            # Cpplint
            RES = distutils.spawn.find_executable(ARGS.cpplint)
            if RES is None:
                log("cpplint ({0}) not found".format(ARGS.cpplint))
            else:
                log("{0} found".format(ARGS.cpplint))
                CHECKER = FileChecker(ARGS.cpplint,
                                      CPP_EXTENSIONS,
                                      None,
                                      "--linelength={0} " \
                                      "--filter=-whitespace/indent," \
                                      "-build/c++11,-runtime/references".format(
                                          ARGS.line_length))
                CHECKERS.append(CHECKER)

            # Pylint for python 2
            RES = distutils.spawn.find_executable(ARGS.pylint2)
            if RES is None:
                log("pylint2 ({0}) not found".format(ARGS.pylint2))
            else:
                log("{0} found".format(ARGS.pylint2))
                CHECKER = FileChecker(ARGS.pylint2, PYTHON_EXTENSIONS,
                                      PYTHON2_SHEBANG_REGEX,
                                      "--reports=no")
                CHECKERS.append(CHECKER)

            # Pylint for python 3
            RES = distutils.spawn.find_executable(ARGS.pylint3)
            if RES is None:
                log("pylint3 ({0}) not found".format(ARGS.pylint3))
            else:
                log("{0} found".format(ARGS.pylint3))
                CHECKER = FileChecker(ARGS.pylint3, PYTHON_EXTENSIONS,
                                      PYTHON3_SHEBANG_REGEX,
                                      "--reports=no")
                CHECKERS.append(CHECKER)

            if len(CHECKERS) is 0:
                raise RuntimeError("No checkers have been detected")

            for p in ARGS.targets:
                FileProcessor(CHECKERS).process_path(p, ARGS.exceptions)

        else:
            sys.exit("An error occured: Unknown action to perform")
        sys.exit()
    except RuntimeError as exception:
        sys.exit("An error occured: {0}".format(exception))

