#! /usr/bin/env python3

"""Codebeautifier

Helper to use linters and formatters.
Currently supported:
 - Python:
   - pylint
   - pylint3
   - autopep8
 - C++:
   - astyle
   - clang-format
   - cpplint
"""

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
import logging
from colorlog import ColoredFormatter
from abc import abstractmethod
from enum import IntEnum, unique


def logger_init(level):
    """Initializes the logger

    Args:
        level: The log level of the logger to be initialized
    """

    formatter = ColoredFormatter(
        "%(log_color)s%(levelname)s%(reset)s %(message)s",
        datefmt=None,
        reset=True,
        log_colors={
            'DEBUG': 'cyan',
            'INFO': 'green',
            'WARNING': 'yellow',
            'ERROR': 'red',
            'CRITICAL': 'bold_red'
        })
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    Main.logger = logging.getLogger("codebeautifier")
    Main.logger.addHandler(handler)
    Main.logger.setLevel(level)


def search_program(match):
    """Searches a program in the system PATH that matches a
    provided regex

    Args:
        match (str): Regex to match a program name

    Returns:
        list: The list of candidates
    """

    regex = re.compile(match)
    paths = os.getenv("PATH").split(":")
    candidates = []
    visited = {}

    # For all directories in $PATH
    for path in paths:
        if os.path.isdir(path):
            # For all files in a subdirectory
            for afile in os.listdir(path):
                absfile = os.path.join(path, afile)
                # Directory was not visited before
                if not absfile in visited:
                    # File in directory is an executable file
                    if os.path.isfile(absfile) and os.access(absfile, os.X_OK):
                        # It fulfills the regex
                        if regex.match(afile) != None:
                            candidates.append(absfile)
                    # Mark the directory to visit it only once
                    visited[absfile] = True

    return candidates


def get_extension(filename):
    """Returns the extension of a file
    """
    return os.path.splitext(filename)[1]


def get_shebang(filename):
    """Gets the shebang of a script.
    It must be formatted as specified in IEEE POSIX.1-2008

    Args:
        filename (str): The file to examine

    Returns:
        The shebang. None if it could not be retrieved.
    """
    try:
        with open(filename, 'r') as fhdl:
            line = fhdl.readline()
            if len(line) > 2 and line[0] == '#' and line[1] == '!':
                return line
    except UnicodeDecodeError:
        Main.logger.error("Fail to read from \"" + filename + "\"")
    return None


def process_file(filename, command_table, strict, ignores):
    """Execute commands on a file

    Args:
        filename (str): Name of the file to be processed
        commands_table (dict): list of command for languages
        strict (bool): if True, aborts on error
    """
    try:

        avoid = False
        for ignored in ignores:
            if re.match(ignored, filename) is not None:
                avoid = True
                break
        if avoid is True:
            return

        file_processed = None
        for _, tools in command_table.items():
            checker = tools[0]
            ret = checker.check(filename)
            if LangChecker.Status.no_error in ret:
                file_processed = checker.lang()
                tools[1].execute(filename)
                break
        if file_processed is not None:
            Main.logger.debug("processed " + filename + " as " +
                              file_processed)
        else:
            Main.logger.critical("Fail to process \"{0}\"".format(filename))
            for err in ret:
                Main.logger.error("     > " +str(err))
            if strict is True:
                sys.exit(2)

    except RuntimeError as exception:
        Main.logger.critical("{0}".format(exception))
        if strict is True:
            sys.exit(3)


def parse_args(raw_args):
    """Parse command-line arguments and returns the parser

    Args:
        raw_args (list): The list program arguments

    Returns:
        The parser fully set
    """

    # Create main parser
    parser = argparse.ArgumentParser(prog="codebeautifer",
                                     description='Coding style helper',
                                     prefix_chars='+-')
    parser.add_argument('--verbose', '-v', action='store_true')
    parser.add_argument('--quiet', '+v', action='store_true')
    root_subparser = parser.add_subparsers(dest="function")

    # FORMAT
    format_parser = root_subparser.add_parser('format', help='Format files')
    format_parser.add_argument('--clang-format', '-c',
                               help='Path to clang-format',
                               type=str, default=None)
    format_parser.add_argument('--autopep8', '-A', help='Path to autopep8',
                               type=str, default="autopep8")
    format_parser.add_argument('--astyle', '-a', help='Path to astyle',
                               type=str, default="astyle")
    format_parser.add_argument('--line-length', "-l", help='Line length',
                               type=int, default=80)
    format_parser.add_argument("targets", type=str, nargs="+",
                               metavar="files or directories")
    format_parser.add_argument("--ignored-paths", "-e", type=str, nargs="*",
                               metavar="Unprocessed paths")
    format_parser.add_argument("--strict", "-S", action='store_true')

    # CHECK
    check_parser = root_subparser.add_parser('check', help='Check files')
    check_parser.add_argument('--line-length', "-l", help='Line length',
                              type=int, default=80)
    check_parser.add_argument('--cpplint', '-c', help='Path to cpplint',
                              type=str, default="cpplint")
    check_parser.add_argument('--pylint2', '-p2', help='Path to pylint2',
                              type=str, default="pylint")
    check_parser.add_argument('--pylint3', '-p3', help='Path to pylint3',
                              type=str, default="pylint3")
    check_parser.add_argument('--checkstyle', '-C', type=str,
                              help='Checkstyle main class or JAR',
                              default='com.puppycrawl.tools.checkstyle.Main')
    check_parser.add_argument("targets", type=str, nargs="+",
                              metavar="files or directories")
    check_parser.add_argument("--ignored-paths", "-e", type=str, nargs="*",
                              metavar="Unprocessed paths")
    check_parser.add_argument("--strict", "-S", action='store_true')

    return parser.parse_args(raw_args[1:])


class Command(object):
    """Wrapper to execute a command-line tool.

    Commands to be used must respect the convention:
        <tool> [options] <target>
    """
    command = None
    quiet = False

    def __init__(self, program, arguments=None, quiet=False):
        self.command = [program]
        if arguments is not None:
            self.command = self.command + arguments
        self.quiet = quiet

    def execute(self, target):
        """Launches the command on a specified target

        Args:
            target (str): target of the command
        """
        command = self.command + [os.path.realpath(target)]
        Main.logger.info(command)
        if self.quiet is True:
            pipes = subprocess.PIPE
        else:
            pipes = None
        proc = subprocess.Popen(command, stdout=pipes, stderr=pipes)
        proc.communicate()

        if proc.returncode != 0:
            raise RuntimeError("Offending file: \"{0}\"".format(target))

    def get_base_command(self):
        """Returns the base command to be executed"""
        return self.command


class LangChecker(object):
    """Infrastructure to determine the programming language used in a file
    """

    file_extensions = None
    file_shebang_regex = None
    file_checker = None

    @unique
    class Status(IntEnum):
        """Error codes used when checking the language of a file"""
        no_error = 0
        no_extension = 1
        no_shebang = 2
        invalid_extension = 3
        invalid_shebang = 4

    def __init__(self, file_checker, file_extensions, file_shebang_regex=None):
        self.file_checker = file_checker
        self.file_extensions = file_extensions
        self.file_shebang_regex = file_shebang_regex

    def check(self, filename):
        """Apply a language check on the provided filename

        Args:
            filename (str): The filename to be checked

        Returns:
            A list of errors
        """
        if not os.path.isfile(filename):
            raise IOError("{0} is not a file".format(filename))
        return self.file_checker(filename,
                                 self.file_extensions,
                                 self.file_shebang_regex)

    @staticmethod
    def check_extension(filename, extensions):
        """Checks the extension of a file among possible extensions

        Args:
            filename (str): The filename to be checked
            extensions (list): List of supported extensions

        Returns:
            Status (ok, no extension, unsupported)
        """
        assert filename is not None
        assert extensions is not None

        ext = get_extension(filename)
        if ext is None:
            return LangChecker.Status.no_extension
        elif ext in extensions:
            return LangChecker.Status.no_error
        else:
            return LangChecker.Status.invalid_extension

    @staticmethod
    def check_shebang(filename, shebang_regex):
        """Checks the shebang of a file among possible shebangs

        Args:
            filename (str): The filename to be checked
            shebang (regex): Allowed shebangs

        Returns:
            Status (ok, no shebang, invalid)
        """
        assert filename is not None
        assert shebang_regex is not None

        shebang = get_shebang(filename)
        if shebang is None:
            return LangChecker.Status.no_shebang
        else:
            regex = re.compile(shebang_regex)
            if regex.match(shebang):
                return LangChecker.Status.no_error
            else:
                return LangChecker.Status.invalid_shebang

    @abstractmethod
    def lang(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        pass


class CppChecker(LangChecker):
    """Checker for C++"""

    EXTENSIONS = [".cc", ".cpp", ".cxx", ".hh", ".hpp", ".hxx", ".h"]

    @staticmethod
    def check_cpp(filename, extensions, _):
        """Checks that the file is a c++ file

        Args:
            filename (str): the file to be checked
            extensions (list): the extensions supported
            shebang_regex (regex): the possible shebangs

        Returns:
            A list of errors
        """
        ret = LangChecker.check_extension(filename, extensions)
        return [ret]

    def __init__(self,
                 extensions=None,
                 checker=check_cpp.__func__):
        if extensions is None:
            extensions = CppChecker.EXTENSIONS
        super().__init__(checker, extensions)

    def lang(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'cpp'


class PythonChecker(LangChecker):
    """Checker for Python"""

    EXTENSIONS = [".py"]

    @staticmethod
    def check_python(filename, extensions, shebang_regex):
        """Checks that the file is a pyton file

        Args:
            filename (str): the file to be checked
            extensions (list): the extensions supported
            shebang_regex (regex): the possible shebangs

        Returns:
            A list of errors
        """

        ret_ext = LangChecker.check_extension(filename, extensions)
        if ret_ext is not LangChecker.Status.no_error:
            ret_sbg = LangChecker.check_shebang(filename, shebang_regex)
            if ret_sbg is not LangChecker.Status.no_error:
                return [ret_ext, ret_sbg]

        return [LangChecker.Status.no_error]

    def __init__(self,
                 shebang_regex,
                 extensions=None,
                 checker=check_python.__func__):
        if extensions is None:
            extensions = PythonChecker.EXTENSIONS
        super().__init__(checker, extensions, shebang_regex)

    def lang(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'python'

class Python2Checker(PythonChecker):
    """Checker for Python 2"""
    def __init__(self):
        super().__init__(r"^(\#\!)(\s*)/usr/bin/env(\s*)python2.*$")

    def lang(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'python2'

class Python3Checker(PythonChecker):
    """Checker for Python 3"""
    def __init__(self):
        super().__init__(r"^(\#\!)(\s*)/usr/bin/env(\s*)python3.*$")

    def lang(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'python3'

class JavaChecker(LangChecker):
    """Checker for Java"""

    EXTENSIONS = [".java"]

    @staticmethod
    def check_java(filename, extensions, _):
        """Checks that the file is a java file

        Args:
            filename (str): the file to be checked
            extensions (list): the extensions supported
            shebang_regex (regex): the possible shebangs

        Returns:
            A list of errors
        """
        ret = LangChecker.check_extension(filename, extensions)
        return [ret]

    def __init__(self,
                 extensions=None,
                 checker=check_java.__func__):
        if extensions is None:
            extensions = JavaChecker.EXTENSIONS
        super().__init__(checker, extensions)

    def lang(self):
        """Get the name of the language checked
        Returns:
            The name of the language checked
        """
        return 'java'


class Main(object):
    """Main utilities"""

    logger = None
    args = None
    commands_table = None

    class Lang(IntEnum):
        """Aliases for languages"""
        CPP = 0
        PYTHON2 = 1
        PYTHON3 = 2
        JAVA = 3

    def add_command(self, command, args, *langs):
        """Registers a command in the commands table

        Args:
            command (str): name of the binary to be run
            args (str): options to forward to the command
            *langs: languages supported by the command
        """

        # Format with astyle
        res = distutils.spawn.find_executable(command)
        if res is None:
            Main.logger.warning(
                "{0} not found".format(command))
        else:
            Main.logger.debug("{0} found".format(command))
            cmd = Command(res, args, self.args.quiet)
            for lang in langs:
                self.commands_table[lang].append(cmd)


    def __init__(self, args):
        self.args = parse_args(args)
        if self.args.verbose is True and self.args.quiet is True:
            raise RuntimeError("--verbose and --quiet cannot be used together")

        log_level = logging.INFO
        if self.args.verbose is True:
            log_level = logging.DEBUG
        elif self.args.quiet is True:
            log_level = logging.CRITICAL
        logger_init(log_level)

        self.commands_table = {
            Main.Lang.CPP:     [CppChecker()],
            Main.Lang.PYTHON2: [Python2Checker()],
            Main.Lang.PYTHON3: [Python3Checker()],
            Main.Lang.JAVA:    [JavaChecker()]
        }

    def init(self):
        """Main entry point"""
        try:


            # Format option
            if self.args.function == "format":

                # Clang-format
                ignore_clang = False
                if self.args.clang_format is None:
                    candidates = search_program(
                        r"clang-format-[1-9]\.[0-9]|^clang-format$")
                    if len(candidates) == 0:
                        Main.logger.warning("clang-format not found")
                        ignore_clang = True
                    else:
                        self.args.clang_format = candidates[0]

                if ignore_clang is False:
                    self.add_command(
                        self.args.clang_format, [
                            "-i",
                            "-style=\"{{BasedOnStyle: Google, " \
                            "ColumnLimit: {0}}}\"".format(self.args.line_length)
                        ],
                        Main.Lang.CPP
                    )

                # Format with astyle
                self.add_command(
                    self.args.astyle, [
                        "--style=google",
                        "--max-code-length={0} -n".format(
                            self.args.line_length)
                    ],
                    Main.Lang.CPP,
                    Main.Lang.JAVA
                )

                # Format with autopep8
                self.add_command(
                    self.args.autopep8, [
                        "--in-place",
                        "--aggressive"
                    ],
                    Main.Lang.PYTHON2,
                    Main.Lang.PYTHON3
                )

            # Check option
            elif self.args.function == "check":

                # Cpplint
                self.add_command(
                    self.args.cpplint, [
                        "--linelength={0}".format(self.args.line_length),
                        "--filter=-whitespace/indent," \
                        "-build/c++11,-runtime/references"
                    ],
                    Main.Lang.CPP
                )

                # Pylint for python 2
                self.add_command(
                    self.args.pylint2, [
                        "--reports=no"
                    ],
                    Main.Lang.PYTHON2
                )

                # Pylint for python 3
                self.add_command(
                    self.args.pylint3, [
                        "--reports=no"
                    ],
                    Main.Lang.PYTHON3
                )

                # Checkstyle for Java
                checkstyle_args = []
                if get_extension(self.args.checkstyle) == '.jar':
                    checkstyle_args.append('-jar')
                checkstyle_args.append(self.args.checkstyle)
                checkstyle_args.append('-c')
                checkstyle_args.append('/google_checks.xml')
                self.add_command(
                    "java", checkstyle_args,
                    Main.Lang.JAVA
                )

            # Invalid options
            else:
                raise RuntimeError("Invalid usage. Relaunch with --help")

            for lang, tools in self.commands_table.items():
                if len(tools) < 2:
                    raise RuntimeError(
                        "No utilities have been detected for " \
                        "language " + str(lang))
        except RuntimeError as exception:
            sys.exit("An error occured: {0}".format(exception))

        return self


    def main(self):
        """Processing core
        """
        ignores = []
        if self.args.ignored_paths:
            for ign in self.args.ignored_paths:
                regex = re.compile(ign)
                ignores.append(regex)

        #===
        # Processing
        #===
        for target in self.args.targets:

            # Avoid exceptions
            if os.path.isdir(target):
                for root, _, files in os.walk(target):
                    for afile in files:
                        process_file(
                            root + '/' + afile,
                            self.commands_table, self.args.strict, ignores
                        )
            else:
                process_file(
                    target, self.commands_table, self.args.strict, ignores
                )

if __name__ == "__main__":
    Main(sys.argv).init().main()

