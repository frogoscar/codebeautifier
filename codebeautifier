#! /usr/bin/env python3

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
import logging
from colorlog import ColoredFormatter
from abc import abstractmethod
from enum import Enum

LOGGER = None



def logger_init(level):
    global LOGGER

    formatter = ColoredFormatter(
        "%(log_color)s%(levelname)s%(reset)s %(message)s",
        datefmt=None,
        reset=True,
        log_colors={
            'DEBUG': 'cyan',
            'INFO': 'green',
            'WARNING': 'yellow',
            'ERROR': 'red',
            'CRITICAL': 'bold_red'
        })
    handler = logging.StreamHandler()
    handler.setFormatter(formatter)
    LOGGER = logging.getLogger("codebeautifier")
    LOGGER.addHandler(handler)
    LOGGER.setLevel(level)


def search_program(match):
    """Searches a program in the system PATH that matches a
    provided regex

    Args:
        match (str): Regex to match a program name

    Returns:
        list: The list of candidates
    """

    regex = re.compile(match)
    paths = os.getenv("PATH").split(":")
    candidates = []
    visited = {}

    # For all directories in $PATH
    for path in paths:
        if os.path.isdir(path):
            # For all files in a subdirectory
            for afile in os.listdir(path):
                absfile = os.path.join(path, afile)
                # Directory was not visited before
                if not absfile in visited:
                    # File in directory is an executable file
                    if os.path.isfile(absfile) and os.access(absfile, os.X_OK):
                        # It fulfills the regex
                        if regex.match(afile) != None:
                            candidates.append(absfile)
                    # Mark the directory to visit it only once
                    visited[absfile] = True

    return candidates


def get_extension(filename):
    """Returns the extension of a file
    """
    return os.path.splitext(filename)[1]


def get_shebang(filename):
    """Gets the shebang of a script.
    It must be formatted as specified in IEEE POSIX.1-2008

    Args:
        filename (str): The file to examine

    Returns:
        The shebang. None if it could not be retrieved.
    """
    try:
        with open(filename, 'r') as fhdl:
            line = fhdl.readline()
            if len(line) > 2 and line[0] == '#' and line[1] == '!':
                return line
    except UnicodeDecodeError as exception:
        LOGGER.error("Fail to read from \"" + filename + "\"")
    return None


def process_file(filename, metatable):
    file_processed = None

    # Avoid exceptions
    if ARGS.ignored_paths is not None:
        avoid = False
        for ignored in ARGS.ignored_paths:
            if re.match(ignored, filename) is not None:
                avoid = True
                break
        if avoid is True:
            return

    try:
        for lang, tools in metatable.items():
            checker = tools[0]
            RET = checker.check(filename)
            if LangChecker.Status.ok in RET:
                file_processed = checker.lang()
                tools[1].execute(filename)
                break
        if file_processed is not None:
            LOGGER.debug("processed " + filename + " as " +
                         file_processed)
        else:
            LOGGER.error("Could not process \"{0}\" because of " \
                         "the following errors".format(filename))
            for err in RET:
                LOGGER.error("     > {0}".format(err))
            if ARGS.strict is True:
                sys.exit(2)

    except RuntimeError as exception:
        LOGGER.critical("{0}".format(exception))
        if ARGS.strict is True:
            sys.exit(3)


def parse_args(raw_args):
    """Parse command-line arguments and returns the parser

    Args:
        raw_args (list): The list program arguments

    Returns:
        The parser fully set
    """

    # Create main parser
    parser = argparse.ArgumentParser(prog="codebeautifer",
                                     description='Coding style helper')
    parser.add_argument('--verbose', '-v', type=int, default=40,
                        metavar="Standard python log level")
    root_subparser = parser.add_subparsers(dest="function")

    # FORMAT
    format_parser = root_subparser.add_parser('format', help='Format files')
    format_parser.add_argument('--clang-format', '-c',
                               help='Path to clang-format',
                               type=str, default=None)
    format_parser.add_argument('--autopep8', '-A', help='Path to autopep8',
                               type=str, default="autopep8")
    format_parser.add_argument('--astyle', '-a', help='Path to astyle',
                               type=str, default="astyle")
    format_parser.add_argument('--line-length', "-l", help='Line length',
                               type=int, default=120)
    format_parser.add_argument("targets", type=str, nargs="+",
                               metavar="files or directories")
    format_parser.add_argument("--ignored-paths", "-e", type=str, nargs="*",
                               metavar="Unprocessed paths")
    format_parser.add_argument("--strict", "-S", action='store_true')

    # CHECK
    check_parser = root_subparser.add_parser('check', help='Check files')
    check_parser.add_argument('--cpplint', '-c', help='Path to cpplint',
                              type=str, default="cpplint")
    check_parser.add_argument('--pylint2', '-p2', help='Path to pylint2',
                              type=str, default="pylint")
    check_parser.add_argument('--pylint3', '-p3', help='Path to pylint3',
                              type=str, default="pylint3")
    check_parser.add_argument('--line-length', "-l", help='Line length',
                              type=int, default=120)
    check_parser.add_argument("targets", type=str, nargs="+",
                              metavar="files or directories")
    check_parser.add_argument("--ignored-paths", "-e", type=str, nargs="*",
                              metavar="Unprocessed paths")
    check_parser.add_argument("--strict", "-S", action='store_true')

    return parser.parse_args(raw_args[1:])


class Command(object):
    base_command = None

    def __init__(self, program, arguments=None):
        if arguments is None:
            self.base_command = program
        else:
            self.base_command = program + " " + arguments

    def execute(self, target):
        command = self.base_command + " " + os.path.realpath(target)
        LOGGER.info(command)
        proc = subprocess.Popen(command, shell=True)
        proc.communicate()

        if proc.returncode != 0:
            raise RuntimeError(
                "{0} returned {1}".format(command, proc.returncode))

class LangChecker(object):

    file_extensions = None
    file_shebang_regex = None
    file_checker = None

    class Status(Enum):
        ok = 0
        no_extension = 1
        no_shebang = 2
        invalid_extension = 3
        invalid_shebang = 4

    def __init__(self, file_checker, file_extensions, file_shebang_regex=None):
        self.file_checker = file_checker
        self.file_extensions = file_extensions
        self.file_shebang_regex = file_shebang_regex

    def check(self, filename):
        if not os.path.isfile(filename):
            raise IOError("{0} is not a file".format(filename))
        return self.file_checker(filename,
                                 self.file_extensions,
                                 self.file_shebang_regex)

    @staticmethod
    def check_extension(filename, extensions):
        assert filename is not None
        assert extensions is not None

        EXT = get_extension(filename)
        if EXT is None:
            return LangChecker.Status.no_extension
        elif EXT in extensions:
            return LangChecker.Status.ok
        else:
            return LangChecker.Status.invalid_extension

    @staticmethod
    def check_shebang(filename, shebang_regex):
        assert filename is not None
        assert shebang_regex is not None

        shebang = get_shebang(filename)
        if shebang is None:
            return LangChecker.Status.no_shebang
        else:
            regex = re.compile(shebang_regex)
            if regex.match(shebang):
                return LangChecker.Status.ok
            else:
                return LangChecker.Status.invalid_shebang

    @abstractmethod
    def lang(self):
        pass


class CppChecker(LangChecker):

    EXTENSIONS = [".cc", ".cpp", ".cxx", ".hh", ".hpp", ".hxx", ".h"]

    @staticmethod
    def check_cpp(filename, extensions, shebang_regex=None):
        RET = LangChecker.check_extension(filename, extensions)
        return [RET]

    def __init__(self,
                 extensions=EXTENSIONS,
                 checker=check_cpp.__func__):
        super().__init__(checker, extensions)

    def lang(self):
        return 'cpp'


class PythonChecker(LangChecker):

    EXTENSIONS = [".py"]

    @staticmethod
    def check_python(filename, extensions, shebang_regex):
        RET_EXT = LangChecker.check_extension(filename, extensions)
        if RET_EXT is not LangChecker.Status.ok:
            RET_SBG = LangChecker.check_shebang(filename, shebang_regex)
            if RET_SBG is not LangChecker.Status.ok:
                return [RET_EXT, RET_SBG]

        return [LangChecker.Status.ok]

    def __init__(self,
                 shebang_regex,
                 extensions=EXTENSIONS,
                 checker=check_python.__func__):
        super().__init__(checker, extensions, shebang_regex)

class Python2Checker(PythonChecker):
    def __init__(self):
        super().__init__(r"^(\#\!)(\s*)/usr/bin/env(\s*)python2.*$")

    def lang(self):
        return 'python2'

class Python3Checker(PythonChecker):
    def __init__(self):
        super().__init__(r"^(\#\!)(\s*)/usr/bin/env(\s*)python3.*$")

    def lang(self):
        return 'python3'



if __name__ == "__main__":
    try:
        ARGS = parse_args(sys.argv)
        logger_init(ARGS.verbose)

        class Lang(Enum):
            CPP     = 0
            PYTHON2 = 1
            PYTHON3 = 2

        METATABLE = {
            Lang.CPP:     [CppChecker()],
            Lang.PYTHON2: [Python2Checker()],
            Lang.PYTHON3: [Python3Checker()]
        }

        def add_command(command, lang):
            METATABLE[lang].append(command)

        # Format option
        if ARGS.function == "format":

            # Clang-format
            CLANG_FOUND = False
            if ARGS.clang_format is None:
                L = search_program(r"clang-format-[1-9]\.[0-9]|^clang-format$")
                if len(L) == 0:
                    LOGGER.warning("clang-format not found")
                else:
                    ARGS.clang_format = L[0]
                    CLANG_FOUND = True
            else:
                RES = distutils.spawn.find_executable(ARGS.clang_format)
                if RES is None:
                    LOGGER.warning("clang-format ({0}) not found".format(
                        ARGS.clang_format))
                else:
                    CLANG_FOUND = True

            if CLANG_FOUND:
                LOGGER.debug("{0} found".format(ARGS.clang_format))
                CMD = Command(ARGS.clang_format,
                              "-i -style=\"{{BasedOnStyle: Google, " \
                              "ColumnLimit: {0}}}\"".format(ARGS.line_length))
                add_command(CMD, Lang.CPP)


            # Format with astyle
            RES = distutils.spawn.find_executable(ARGS.astyle)
            if RES is None:
                LOGGER.warning("astyle ({0}) not found".format(ARGS.astyle))
            else:
                LOGGER.debug("{0} found".format(ARGS.astyle))
                CMD = Command(ARGS.astyle,
                              "--style=google --max-code-length={0} -n".format(
                                              ARGS.line_length))
                add_command(CMD, Lang.CPP)

            # Format with autopep8
            RES = distutils.spawn.find_executable(ARGS.autopep8)
            if RES is None:
                LOGGER.warning(
                    "autopep8 ({0}) not found".format(
                        ARGS.autopep8))
            else:
                LOGGER.debug("{0} found".format(ARGS.autopep8))
                CMD = Command(ARGS.autopep8, "--in-place --aggressive")
                add_command(CMD, Lang.PYTHON2)
                add_command(CMD, Lang.PYTHON3)

        # Check option
        elif ARGS.function == "check":

            # Cpplint
            RES = distutils.spawn.find_executable(ARGS.cpplint)
            if RES is None:
                LOGGER.warning("cpplint ({0}) not found".format(ARGS.cpplint))
            else:
                LOGGER.debug("{0} found".format(ARGS.cpplint))
                CMD = Command(ARGS.cpplint,
                              "--linelength={0} "
                              "--filter=-whitespace/indent,"
                              "-build/c++11,-runtime/references".format(
                                  ARGS.line_length))
                add_command(CMD, Lang.CPP)

            # Pylint for python 2
            RES = distutils.spawn.find_executable(ARGS.pylint2)
            if RES is None:
                LOGGER.warning("pylint2 ({0}) not found".format(ARGS.pylint2))
            else:
                LOGGER.debug("{0} found".format(ARGS.pylint2))
                CMD = Command(ARGS.pylint2, "--reports=no")
                add_command(CMD, Lang.PYTHON2)

            # Pylint for python 3
            RES = distutils.spawn.find_executable(ARGS.pylint3)
            if RES is None:
                LOGGER.warning("pylint3 ({0}) not found".format(ARGS.pylint3))
            else:
                LOGGER.debug("{0} found".format(ARGS.pylint3))
                CMD = Command(ARGS.pylint3, "--reports=no")
                add_command(CMD, Lang.PYTHON3)

        for lang, tools in METATABLE.items():
            if len(tools) < 2:
                raise RuntimeError(
                    "No utilities have been detected for lang {0}".format(lang))
    except RuntimeError as exception:
        sys.exit("An error occured: {0}".format(exception))


    #===
    # Processing
    #===
    for p in ARGS.targets:
        if os.path.isdir(p):
            for root, sdir, files in os.walk(p):
                for f in files:
                    process_file(root + '/' + f, METATABLE)
        else:
            process_file(p, METATABLE)


    sys.exit(0)
 
