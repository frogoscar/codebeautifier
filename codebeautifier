#!/usr/bin/env python
"""codebeautifier

This module is a helper to enforce Ercom's coding style for
different languages (currently C++ and python).

It allows manipulation of tools that do coding style checking
(cpplint, pylint) as well as code
formatter (clang-format, astyle)

"""

import re
import os
import sys
import argparse
import subprocess
import distutils.spawn
from abc import abstractmethod


def search_program(match):
    """Searches a program in the system PATH that matches a
    provided regex

    Args:
        match (str): Regex to match a program name

    Returns:
        list: The list of candidates
    """

    regex = re.compile(match)
    paths = os.getenv("PATH").split(":")
    candidates = []
    visited = {}

    # For all directories in $PATH
    for path in paths:
        if os.path.isdir(path):
            # For all files in a subdirectory
            for afile in os.listdir(path):
                absfile = os.path.join(path, afile)
                # Directory was not visited before
                if not absfile in visited:
                    # File in directory is an executable file
                    if os.path.isfile(absfile) and os.access(absfile, os.X_OK):
                        # It fulfills the regex
                        if regex.match(afile) != None:
                            candidates.append(absfile)
                    # Mark the directory to visit it only once
                    visited[absfile] = True

    return candidates

def get_extension(filename):
    """Returns the extension of a file
    """
    return os.path.splitext(filename)[1]

def log(msg):
    print "-- " + msg

def get_shebang(filename):
    shebang = None
    with open(filename, 'r') as fh:
        line = fh.readline()
        if len(line) > 2 and line[0] == '#' and line[1] == '!':
            return line
    return None


class PathProcessor(object):
    """Allows to do path walking and execute specified
    actions while doing so
    """

    def process_path(self, path, exceptions):
        """Iterates over a path to determine whether it must
        be processed as a directory or as a file

        Args:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """

        if os.path.isdir(path):
            self.process_dir(os.path.abspath(path), exceptions)
        else:
            self.process_file(os.path.abspath(path), exceptions)

    def process_dir(self, path, exceptions):
        """Iterates over a directory

        Args:
            path (str): the path to examine
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if os.path.isdir(path):
                lst = os.listdir(path)
                for pth in lst:
                    folder = os.path.join(path, pth)
                    if os.path.isdir(folder):
                        self.process_dir(folder, exceptions)
                    else:
                        self.process_file(folder, exceptions)
            else:
                raise RuntimeError("'{0}' is not a directory".format(p))

    @abstractmethod
    def process_file(self, path, exceptions):
        """Action to be executed when processing a file
        This method aims at being overloaded by a subclass

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        pass


class FileChecker(PathProcessor):
    """Helper to lint files by linting programs
    """
    tool_path = None
    tool_args = None
    extensions = None
    shebang = None

    def __init__(self, tool_path, extensions, shebang=None, tool_args=""):
        self.tool_path = tool_path
        self.tool_args = tool_args
        self.extensions = extensions
        if shebang is not None:
            self.shebang = re.compile(shebang)
        else:
            self.shebang = None

    def process_file(self, path, exceptions):
        """Action to be done on a file by a linting program

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if not os.path.isfile(path):
                raise RuntimeError("{0} is not a file".format(path))

            # Extension/shebang not handled by checker?
            if not get_extension(path) in self.extensions:
                if self.shebang is None:
                    return False
                shebang = get_shebang(path)
                if shebang is None:
                    return False
                if self.shebang.search(shebang) == None:
                    return False

            command = "{0} {1} {2}".format(self.tool_path, self.tool_args, path)
            log(command)
            proc = subprocess.Popen(command, shell=True,
                                    cwd=os.path.dirname(
                                        os.path.realpath(self.tool_path)))
            proc.communicate()
            if proc.returncode != 0:
                raise RuntimeError("Error when executing {0}".format(
                    self.tool_path))

        return True

class FileFormatter(PathProcessor):
    """Helper to format files by code formatter programs
    """
    tool_path = None
    tool_args = None
    extensions = None
    shebang = None

    def __init__(self, tool_path, extensions, shebang=None, tool_args=""):
        self.tool_path = tool_path
        self.tool_args = tool_args
        self.extensions = extensions
        if shebang is not None:
            self.shebang = re.compile(shebang)
        else:
            self.shebang = None

    def process_file(self, path, exceptions):
        """Action to be done on a file by a linting program

        Args:
            path (str): the path of the file
            exceptions (list): the list of paths not to process.
                Regex are allowed.

        Returns:
            True if the file was successfully processed.
            False if the file could not be processed.
            Raises an exception on error
        """
        avoid = False
        if exceptions != None:
            for ex in exceptions:
                avoid = avoid or (re.match(ex, path) != None)
        if not avoid:
            if not os.path.isfile(path):
                raise RuntimeError("{0} is not a file".format(path))

            # Extension/shebang not handled by checker?
            if not get_extension(path) in self.extensions:
                if self.shebang is None:
                    return False
                shebang = get_shebang(path)
                if not self.shebang.match(shebang):
                    return False

            command = "{0} {1} {2}".format(self.tool_path,
                                           self.tool_args, path)
            log(command)
            proc = subprocess.Popen(command, shell=True,
                                    cwd=os.path.dirname(
                                        os.path.realpath(self.tool_path)))
            proc.communicate()
            if proc.returncode != 0:
                raise RuntimeError(
                    "Error when executing {0}".format(self.tool_path))

        return True

class FileProcessor(PathProcessor):
    processors = None

    def __init__(self, processors):
        self.processors = processors

    def process_file(self, path, exceptions):
        for proc in self.processors:
            if proc.process_file(path, exceptions):
                return True
        return False


def parse_args(raw_args):
    """Parse command-line arguments and returns the parser

    Args:
        raw_args (list): The list program arguments

    Returns:
        The parser fully set
    """

    # Create main parser
    parser = argparse.ArgumentParser(prog="codebeautifer",
                                     description='Coding style helper')
    root_subparser = parser.add_subparsers(dest="function")

    # FORMAT
    format_parser = root_subparser.add_parser('format', help='Format files')
    format_parser.add_argument('--clang-format', '-c',
                               help='Path to clang-format',
                               type=str, default=None)
    format_parser.add_argument('--astyle', '-a', help='Path to astyle',
                               type=str, default="astyle")
    format_parser.add_argument('--line-length', "-l", help='Line length',
                               type=int, default=120)
    format_parser.add_argument("targets", type=str, nargs="+",
                               metavar="files or directories")
    format_parser.add_argument("--exceptions", "-e", type=str, nargs="*",
                               metavar="Unprocessed paths")

    # CHECK
    check_parser = root_subparser.add_parser('check', help='Check files')
    check_parser.add_argument('--cpplint', '-c', help='Path to cpplint',
                              type=str, default="cpplint")
    check_parser.add_argument('--pylint', '-p', help='Path to pylint',
                              type=str, default="pylint")
    check_parser.add_argument('--line-length', "-l", help='Line length',
                              type=int, default=120)
    check_parser.add_argument("targets", type=str, nargs="+",
                              metavar="files or directories")
    check_parser.add_argument("--exceptions", "-e", type=str, nargs="*",
                              metavar="Unprocessed paths")

    return parser.parse_args(raw_args[1:])


if __name__ == "__main__":
    try:
        ARGS = parse_args(sys.argv)
        CPP_EXTENSIONS = [ ".cc", ".cpp", ".cxx", ".hh", ".hpp", ".hxx", ".h" ]
        PYTHON_EXTENSIONS = [ ".py" ]
        JAVA_EXTENSIONS = [ ".java" ]

        # Format option
        if ARGS.function == "format":
            formatters = []

            # Clang-format
            clang_found = False
            if ARGS.clang_format is None:
                L = search_program(r"clang-format-[1-9]\.[0-9]|^clang-format$")
                if len(L) == 0:
                    log("clang-format not found")
                else:
                    ARGS.clang_format = L[0]
                    clang_found = True
            else:
                RES = distutils.spawn.find_executable(ARGS.clang_format)
                if RES is None:
                    log("clang-format ({0}) not found".format(ARGS.clang_format))
                else:
                    clang_found = True

            if clang_found:
                log("{0} found".format(ARGS.clang_format))
                FORMATTER = FileFormatter(ARGS.clang_format,
                                          CPP_EXTENSIONS,
                                          None,
                                          "-i -style=\"{{BasedOnStyle: Google"\
                                          ", ColumnLimit: {0}}}\"".format(
                                              ARGS.line_length))
                formatters.append(FORMATTER)

            # Format with astyle
            RES = distutils.spawn.find_executable(ARGS.astyle)
            if RES is None:
                log("astyle ({0}) not found".format(ARGS.astyle))
            else:
                log("{0} found".format(ARGS.astyle))
                FORMATTER = FileFormatter(ARGS.astyle,
                                          CPP_EXTENSIONS,
                                          None,
                                          "--style=google " \
                                          "--max-code-length={0} -n".format(
                                              ARGS.line_length))
                formatters.append(FORMATTER)

            if len(formatters) is 0:
                raise RuntimeError("No formatters have been detected")

            for p in ARGS.targets:
                FileProcessor(formatters).process_path(p, ARGS.exceptions)

        # Check option
        elif ARGS.function == "check":
            checkers = []

            # Cpplint
            RES = distutils.spawn.find_executable(ARGS.cpplint)
            if RES is None:
                log("cpplint ({0}) not found".format(ARGS.cpplint))
            else:
                log("{0} found".format(ARGS.cpplint))
                CHECKER = FileChecker(ARGS.cpplint,
                                      CPP_EXTENSIONS,
                                      None,
                                      "--linelength={0} " \
                                      "--filter=-whitespace/indent," \
                                      "-build/c++11,-runtime/references".format(
                                          ARGS.line_length))
                checkers.append(CHECKER)

            # Pylint
            RES = distutils.spawn.find_executable(ARGS.pylint)
            if RES is None:
                log("pylint ({0}) not found".format(ARGS.pylint))
            else:
                log("{0} found".format(ARGS.pylint))
                CHECKER = FileChecker(ARGS.pylint, PYTHON_EXTENSIONS, r"python")
                checkers.append(CHECKER)

            for p in ARGS.targets:
                FileProcessor(checkers).process_path(p, ARGS.exceptions)

        else:
            sys.exit("An error occured: Unknown action to perform")
        sys.exit()
    except RuntimeError as exception:
        sys.exit("An error occured: {0}".format(exception))

